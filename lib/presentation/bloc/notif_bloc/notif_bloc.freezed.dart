// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'notif_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NotifEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function() r,
    required TResult Function() s,
    required TResult Function() d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function()? r,
    TResult? Function()? s,
    TResult? Function()? d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function()? r,
    TResult Function()? s,
    TResult Function()? d,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(A value) a,
    required TResult Function(R value) r,
    required TResult Function(S value) s,
    required TResult Function(D value) d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(A value)? a,
    TResult? Function(R value)? r,
    TResult? Function(S value)? s,
    TResult? Function(D value)? d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(A value)? a,
    TResult Function(R value)? r,
    TResult Function(S value)? s,
    TResult Function(D value)? d,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotifEventCopyWith<$Res> {
  factory $NotifEventCopyWith(
          NotifEvent value, $Res Function(NotifEvent) then) =
      _$NotifEventCopyWithImpl<$Res, NotifEvent>;
}

/// @nodoc
class _$NotifEventCopyWithImpl<$Res, $Val extends NotifEvent>
    implements $NotifEventCopyWith<$Res> {
  _$NotifEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AImplCopyWith<$Res> {
  factory _$$AImplCopyWith(_$AImpl value, $Res Function(_$AImpl) then) =
      __$$AImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AImplCopyWithImpl<$Res>
    extends _$NotifEventCopyWithImpl<$Res, _$AImpl>
    implements _$$AImplCopyWith<$Res> {
  __$$AImplCopyWithImpl(_$AImpl _value, $Res Function(_$AImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AImpl implements A {
  const _$AImpl();

  @override
  String toString() {
    return 'NotifEvent.a()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function() r,
    required TResult Function() s,
    required TResult Function() d,
  }) {
    return a();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function()? r,
    TResult? Function()? s,
    TResult? Function()? d,
  }) {
    return a?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function()? r,
    TResult Function()? s,
    TResult Function()? d,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(A value) a,
    required TResult Function(R value) r,
    required TResult Function(S value) s,
    required TResult Function(D value) d,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(A value)? a,
    TResult? Function(R value)? r,
    TResult? Function(S value)? s,
    TResult? Function(D value)? d,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(A value)? a,
    TResult Function(R value)? r,
    TResult Function(S value)? s,
    TResult Function(D value)? d,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }
}

abstract class A implements NotifEvent {
  const factory A() = _$AImpl;
}

/// @nodoc
abstract class _$$RImplCopyWith<$Res> {
  factory _$$RImplCopyWith(_$RImpl value, $Res Function(_$RImpl) then) =
      __$$RImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RImplCopyWithImpl<$Res>
    extends _$NotifEventCopyWithImpl<$Res, _$RImpl>
    implements _$$RImplCopyWith<$Res> {
  __$$RImplCopyWithImpl(_$RImpl _value, $Res Function(_$RImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RImpl implements R {
  const _$RImpl();

  @override
  String toString() {
    return 'NotifEvent.r()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function() r,
    required TResult Function() s,
    required TResult Function() d,
  }) {
    return r();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function()? r,
    TResult? Function()? s,
    TResult? Function()? d,
  }) {
    return r?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function()? r,
    TResult Function()? s,
    TResult Function()? d,
    required TResult orElse(),
  }) {
    if (r != null) {
      return r();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(A value) a,
    required TResult Function(R value) r,
    required TResult Function(S value) s,
    required TResult Function(D value) d,
  }) {
    return r(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(A value)? a,
    TResult? Function(R value)? r,
    TResult? Function(S value)? s,
    TResult? Function(D value)? d,
  }) {
    return r?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(A value)? a,
    TResult Function(R value)? r,
    TResult Function(S value)? s,
    TResult Function(D value)? d,
    required TResult orElse(),
  }) {
    if (r != null) {
      return r(this);
    }
    return orElse();
  }
}

abstract class R implements NotifEvent {
  const factory R() = _$RImpl;
}

/// @nodoc
abstract class _$$SImplCopyWith<$Res> {
  factory _$$SImplCopyWith(_$SImpl value, $Res Function(_$SImpl) then) =
      __$$SImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SImplCopyWithImpl<$Res>
    extends _$NotifEventCopyWithImpl<$Res, _$SImpl>
    implements _$$SImplCopyWith<$Res> {
  __$$SImplCopyWithImpl(_$SImpl _value, $Res Function(_$SImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SImpl implements S {
  const _$SImpl();

  @override
  String toString() {
    return 'NotifEvent.s()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function() r,
    required TResult Function() s,
    required TResult Function() d,
  }) {
    return s();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function()? r,
    TResult? Function()? s,
    TResult? Function()? d,
  }) {
    return s?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function()? r,
    TResult Function()? s,
    TResult Function()? d,
    required TResult orElse(),
  }) {
    if (s != null) {
      return s();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(A value) a,
    required TResult Function(R value) r,
    required TResult Function(S value) s,
    required TResult Function(D value) d,
  }) {
    return s(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(A value)? a,
    TResult? Function(R value)? r,
    TResult? Function(S value)? s,
    TResult? Function(D value)? d,
  }) {
    return s?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(A value)? a,
    TResult Function(R value)? r,
    TResult Function(S value)? s,
    TResult Function(D value)? d,
    required TResult orElse(),
  }) {
    if (s != null) {
      return s(this);
    }
    return orElse();
  }
}

abstract class S implements NotifEvent {
  const factory S() = _$SImpl;
}

/// @nodoc
abstract class _$$DImplCopyWith<$Res> {
  factory _$$DImplCopyWith(_$DImpl value, $Res Function(_$DImpl) then) =
      __$$DImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DImplCopyWithImpl<$Res>
    extends _$NotifEventCopyWithImpl<$Res, _$DImpl>
    implements _$$DImplCopyWith<$Res> {
  __$$DImplCopyWithImpl(_$DImpl _value, $Res Function(_$DImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DImpl implements D {
  const _$DImpl();

  @override
  String toString() {
    return 'NotifEvent.d()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function() r,
    required TResult Function() s,
    required TResult Function() d,
  }) {
    return d();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function()? r,
    TResult? Function()? s,
    TResult? Function()? d,
  }) {
    return d?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function()? r,
    TResult Function()? s,
    TResult Function()? d,
    required TResult orElse(),
  }) {
    if (d != null) {
      return d();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(A value) a,
    required TResult Function(R value) r,
    required TResult Function(S value) s,
    required TResult Function(D value) d,
  }) {
    return d(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(A value)? a,
    TResult? Function(R value)? r,
    TResult? Function(S value)? s,
    TResult? Function(D value)? d,
  }) {
    return d?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(A value)? a,
    TResult Function(R value)? r,
    TResult Function(S value)? s,
    TResult Function(D value)? d,
    required TResult orElse(),
  }) {
    if (d != null) {
      return d(this);
    }
    return orElse();
  }
}

abstract class D implements NotifEvent {
  const factory D() = _$DImpl;
}

/// @nodoc
mixin _$NotifState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotifStateCopyWith<$Res> {
  factory $NotifStateCopyWith(
          NotifState value, $Res Function(NotifState) then) =
      _$NotifStateCopyWithImpl<$Res, NotifState>;
}

/// @nodoc
class _$NotifStateCopyWithImpl<$Res, $Val extends NotifState>
    implements $NotifStateCopyWith<$Res> {
  _$NotifStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$NotifStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'NotifState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements NotifState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$ASImplCopyWith<$Res> {
  factory _$$ASImplCopyWith(_$ASImpl value, $Res Function(_$ASImpl) then) =
      __$$ASImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ASImplCopyWithImpl<$Res>
    extends _$NotifStateCopyWithImpl<$Res, _$ASImpl>
    implements _$$ASImplCopyWith<$Res> {
  __$$ASImplCopyWithImpl(_$ASImpl _value, $Res Function(_$ASImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ASImpl implements AS {
  const _$ASImpl();

  @override
  String toString() {
    return 'NotifState.aS()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ASImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) {
    return aS();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) {
    return aS?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) {
    if (aS != null) {
      return aS();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) {
    return aS(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) {
    return aS?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) {
    if (aS != null) {
      return aS(this);
    }
    return orElse();
  }
}

abstract class AS implements NotifState {
  const factory AS() = _$ASImpl;
}

/// @nodoc
abstract class _$$SSImplCopyWith<$Res> {
  factory _$$SSImplCopyWith(_$SSImpl value, $Res Function(_$SSImpl) then) =
      __$$SSImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SSImplCopyWithImpl<$Res>
    extends _$NotifStateCopyWithImpl<$Res, _$SSImpl>
    implements _$$SSImplCopyWith<$Res> {
  __$$SSImplCopyWithImpl(_$SSImpl _value, $Res Function(_$SSImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SSImpl implements SS {
  const _$SSImpl();

  @override
  String toString() {
    return 'NotifState.sS()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SSImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) {
    return sS();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) {
    return sS?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) {
    if (sS != null) {
      return sS();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) {
    return sS(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) {
    return sS?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) {
    if (sS != null) {
      return sS(this);
    }
    return orElse();
  }
}

abstract class SS implements NotifState {
  const factory SS() = _$SSImpl;
}

/// @nodoc
abstract class _$$RSImplCopyWith<$Res> {
  factory _$$RSImplCopyWith(_$RSImpl value, $Res Function(_$RSImpl) then) =
      __$$RSImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RSImplCopyWithImpl<$Res>
    extends _$NotifStateCopyWithImpl<$Res, _$RSImpl>
    implements _$$RSImplCopyWith<$Res> {
  __$$RSImplCopyWithImpl(_$RSImpl _value, $Res Function(_$RSImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RSImpl implements RS {
  const _$RSImpl();

  @override
  String toString() {
    return 'NotifState.rS()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RSImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) {
    return rS();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) {
    return rS?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) {
    if (rS != null) {
      return rS();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) {
    return rS(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) {
    return rS?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) {
    if (rS != null) {
      return rS(this);
    }
    return orElse();
  }
}

abstract class RS implements NotifState {
  const factory RS() = _$RSImpl;
}

/// @nodoc
abstract class _$$DSImplCopyWith<$Res> {
  factory _$$DSImplCopyWith(_$DSImpl value, $Res Function(_$DSImpl) then) =
      __$$DSImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DSImplCopyWithImpl<$Res>
    extends _$NotifStateCopyWithImpl<$Res, _$DSImpl>
    implements _$$DSImplCopyWith<$Res> {
  __$$DSImplCopyWithImpl(_$DSImpl _value, $Res Function(_$DSImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DSImpl implements DS {
  const _$DSImpl();

  @override
  String toString() {
    return 'NotifState.dS()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DSImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() aS,
    required TResult Function() sS,
    required TResult Function() rS,
    required TResult Function() dS,
  }) {
    return dS();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? aS,
    TResult? Function()? sS,
    TResult? Function()? rS,
    TResult? Function()? dS,
  }) {
    return dS?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? aS,
    TResult Function()? sS,
    TResult Function()? rS,
    TResult Function()? dS,
    required TResult orElse(),
  }) {
    if (dS != null) {
      return dS();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(AS value) aS,
    required TResult Function(SS value) sS,
    required TResult Function(RS value) rS,
    required TResult Function(DS value) dS,
  }) {
    return dS(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(AS value)? aS,
    TResult? Function(SS value)? sS,
    TResult? Function(RS value)? rS,
    TResult? Function(DS value)? dS,
  }) {
    return dS?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(AS value)? aS,
    TResult Function(SS value)? sS,
    TResult Function(RS value)? rS,
    TResult Function(DS value)? dS,
    required TResult orElse(),
  }) {
    if (dS != null) {
      return dS(this);
    }
    return orElse();
  }
}

abstract class DS implements NotifState {
  const factory DS() = _$DSImpl;
}
